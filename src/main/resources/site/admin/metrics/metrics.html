<!DOCTYPE html>
<html lang = "en">

    <head>

        <meta charset = "utf-8"/>
        <meta name = "viewport" content = "width=device-width, initial-scale=1"/>
        <meta name = "description" content = "Personal GitHub projects showcase website. Admin site performance metrics page."/>

        <link rel = "stylesheet" href = "../../styles.css"/>
        <link rel = "icon" type = "image/x-icon" href = "../../images/favicon.ico"/>

        <title>Gatto's Lab</title>

    </head>

    <body class = "background">

        <nav class = "navbar">

            <div class = "nav-container">

                <div class = "nav-item">
                    <img src = "../../images/GITHUB-LOGO.svg" class = "nav-icon" alt = "GitHub logo"/>
                    <a href = "https://github.com/Clamentos" target = "_blank">Follow me on GitHub</a>
                </div>

            </div>

            <div class = "nav-crumb">
                <a href = "../../index.html">Home</a> > <a href = "../index.html">Admin</a> > Metrics
            </div>

        </nav>

        <main>

            <div class = "cards-container">

                <form class = "charts-form" onsubmit = "onSubmitEvent(event)">

                    <div class = "charts-form-group">

                        <div class = "charts-form-input-group">
                            <label for = "startTimestamp">Start timestamp</label>
                            <input class = "chart-form-input" type = "datetime-local" name = "startTimestamp">
                        </div>

                        <div class = "charts-form-input-group">
                            <label for = "endTimestamp">End timestamp</label>
                            <input class = "chart-form-input" type = "datetime-local" name = "endTimestamp">
                        </div>

                        <div class = "charts-form-input-group">
                            <label for = "chartTypes">Chart types</label>
                            <input class = "chart-form-input" type = "text" name = "chartTypes" placeholder = "RequestsPerSecondChart,...">
                        </div>

                        <div class = "charts-form-input-group">
                            <label for = "httpStatuses">HTTP Statuses</label>
                            <input class = "chart-form-input" type = "text" name = "httpStatuses" placeholder = "200,404,...">
                        </div>

                    </div>

                    <button class = "form-button" type = "submit">Filter</button>
                    <p id = "API-error" class = "form-error"></p>

                </form>

                <div id = "RequestsPerSecondChart"></div>
                <div id = "LatencyChart"></div>

            </div>

        </main>

    </body>

    <script src = "../../js/CheckLogout.js"></script>
    <script src = "https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js"></script>

    <script>

        Chart.defaults.color = "#FFFFFF";
        const allChartTypes = ["RequestsPerSecondChart", "LatencyChart"];
        const allCollectedStatuses = [200, 304, 400, 401, 403, 404, 405, 415, 429, 500, 503];
        const allLatencyBuckets = ["1-5", "6-10", "11-20", "21-50", "51-100", "101-500"];

        const charts = [];
        const visitedCharts = new Map(); // chart type -> status[]

        document.getElementById("API-error").innerHTML = "";
        checkLogout("/admin/login.html");
        fetchAndRenderMetrics(0, 999999999999999, allChartTypes, allCollectedStatuses);

        function onSubmitEvent(event) {

            event.preventDefault();

            const formStartTimestamp = event.target.startTimestamp.value;
            const formEndTimestamp = event.target.endTimestamp.value;
            const chartTypes = event.target.chartTypes.value;
            const httpStatuses = event.target.httpStatuses.value;

            fetchAndRenderMetrics(

                formStartTimestamp === "" ? 0 : new Date(formStartTimestamp).getMilliseconds(),
                formEndTimestamp === "" ? 999999999999999 : new Date(formEndTimestamp).getMilliseconds(),
                chartTypes === "" ? null : String(chartTypes).split(","),
                httpStatuses === "" ? null : String(httpStatuses).split(",").map(s => Number.parseInt(s))
            );
        }

        function fetchAndRenderMetrics(startTimestampFilter, endTimestampFilter, chartTypesFilter, httpStatusesFilter) {

            fetch(

                "/admin/api/observability/performance-charts",

                {
                    method: "POST",
                    headers: new Headers({"content-type": "application/json"}),

                    body: JSON.stringify({

                        startTimestamp: startTimestampFilter,
                        endTimestamp: endTimestampFilter,
                        chartTypes: chartTypesFilter,
                        httpStatuses: httpStatusesFilter
                    })
                }

            ).then(response => {

                if(response.status === 200) {

                    response.json().then(json => {

                        visitedCharts.clear();
                        visitedCharts.set("RequestsPerSecondChart", new Set());
                        visitedCharts.set("LatencyChart", new Set());
                        for(const chart of charts) chart.destroy();

                        const rpsChartMap = new Map(); // status -> chart[]
                        const latencyChartMap = new Map(); // status -> chart[]
                        const collectedStatuses = new Map(); // chartType -> status[]
                        aggregateByStatus(json, rpsChartMap, latencyChartMap, collectedStatuses);

                        const rpsDatasetsMap = new Map();  // status -> path -> data[]
                        const rpsTimestampsMap = new Map(); // status -> timestamp[]
                        const latencyDatasetsMap = new Map(); // status -> path -> data[]
                        joinCharts(rpsChartMap, rpsDatasetsMap, rpsTimestampsMap, latencyChartMap, latencyDatasetsMap);

                        const rpsDatasets = new Map(); // status -> chartData[]
                        const latencyDatasets = new Map(); // status -> chartData[]
                        finalizeDatasets(rpsDatasetsMap, rpsDatasets, latencyDatasetsMap, latencyDatasets, collectedStatuses);

                        const collectedRpsStatuses = collectedStatuses.get("RequestsPerSecondChart");
                        const collectedLatencyStatuses = collectedStatuses.get("LatencyChart");
                        tabs(collectedRpsStatuses, "RequestsPerSecondChart", rpsTimestampsMap, rpsDatasets, null);
                        tabs(collectedLatencyStatuses, "LatencyChart", null, null, latencyDatasets);
                        selectTab("RequestsPerSecondChart", collectedRpsStatuses[0], true);
                        selectTab("LatencyChart", collectedLatencyStatuses[0], true);
                    });
                }

                else {

                    showError(response);
                }
            })
            .catch(error_ => showError(error_));
        }

        function aggregateByStatus(json, rpsChartMap, latencyChartMap, collectedStatuses) {

            for(const item of json) {

                mapComputeIfAbsent(collectedStatuses, item.chartType, () => []).push(item.httpStatus);

                mapComputeIfAbsent(

                    item.chartType === "LatencyChart" ? latencyChartMap : rpsChartMap,
                    item.httpStatus,
                    () => []
                )
                .push(item);
            }
        }

        function joinCharts(rpsChartMap, rpsDatasetsMap, rpsTimestampsMap, latencyChartMap, latencyDatasetsMap) {

            for(const [status, data] of rpsChartMap) {

                for(const chart of data) {

                    const innerMap = mapComputeIfAbsent(rpsDatasetsMap, status, () => new Map());
                    const timestamps = chart.chart.labels.map(e => new Date(e).toLocaleString());
                    mapComputeIfAbsent(rpsTimestampsMap, status, () => []).push(...timestamps);

                    for(const dataset of chart.chart.datasets) {

                        mapComputeIfAbsent(innerMap, dataset.label, () => []).push(...dataset.data);
                    }
                }
            }

            for(const [status, data] of latencyChartMap) {

                for(const chart of data) {

                    const innerMap = mapComputeIfAbsent(latencyDatasetsMap, status, () => new Map());

                    for(const dataset of chart.chart.datasets) {

                        mapComputeIfAbsent(innerMap, dataset.label, () => []).push(...dataset.data);
                    }
                }
            }
        }

        function finalizeDatasets(rpsDatasetsMap, rpsDatasets, latencyDatasetsMap, latencyDatasets, collectedStatuses) {

            for(const status of collectedStatuses.get("RequestsPerSecondChart")) {

                const rpsDatasetsArr = [];

                for(const [path, data] of rpsDatasetsMap.get(status)) {

                    rpsDatasetsArr.push({

                        label: path,
                        data: data,
                        fill: true,
                        borderWidth: 1,
                        pointRadius: 2,
                        hidden: path !== "/"
                    });
                }

                rpsDatasets.set(status, rpsDatasetsArr);
            }

            for(const status of collectedStatuses.get("LatencyChart")) {

                const latencyDatasetsArr = [];

                for(const [path, data] of latencyDatasetsMap.get(status)) {

                    latencyDatasetsArr.push({

                        label: path,
                        data: data,
                        hidden: path !== "/"
                    });
                }

                latencyDatasets.set(status, latencyDatasetsArr);
            }
        }

        function getChartOptions(title, xCallback, yCallback) {

            const options = {

                responsive: true,

                plugins: {

                    legend: {

                        position: "right"
                    },

                    title: {

                        display: true,
                        text: title
                    },

                    colors: {

                        enabled: true
                    },

                    decimation: {

                        enabled: true,
                        algorithm: 'min-max',
                    }
                },

                scales: {

                    x: {

                        grid: {

                            color: "rgba(255, 255, 255, 0.15)"
                        }
                    },

                    y: {

                        grid: {

                            color: "rgba(255, 255, 255, 0.15)"
                        }
                    }
                }
            };

            if(xCallback !== undefined) options.scales.x["ticks"] = { callback: xCallback };
            if(yCallback !== undefined) options.scales.y["ticks"] = { callback: yCallback };

            return options;
        }

        function renderChart(status, chartType, canvas, rpsTimestampsMap, rpsDatasets, latencyDatasets) {

            if(visitedCharts.get(chartType).has(status)) return;
            let chart = null;

            if(chartType === "RequestsPerSecondChart") {

                chart = new Chart(canvas, {

                    type: "line",

                    data: {

                        labels: rpsTimestampsMap.get(status),
                        datasets: rpsDatasets.get(status)
                    },

                    options: getChartOptions(`Requests per second for HTTP status: ${status}`)
                });
            }

            else {

                chart = new Chart(canvas, {

                    type: "bubble",

                    data: {

                        datasets: latencyDatasets.get(status)
                    },

                    options: getChartOptions(

                        `Latency distributions HTTP status: ${status}`,

                        (value, index, ticks) => new Date(value).toLocaleString(),

                        (value, index, ticks) => {

                            const val = Number.parseInt(value);

                            if(val % 1 === 0) return `${allLatencyBuckets[val]} ms`;
                            else return "-";
                        }
                    )
                });
            }

            visitedCharts.get(chartType).add(status);
            charts.push(chart);
        }

        function mapComputeIfAbsent(map, key, func) {

            const current = map.get(key);

            if(current == null) {

                const newValue = func();
                map.set(key, newValue);

                return newValue;
            }

            return current;
        }

        function showError(error) {

            document.getElementById("API-error").innerHTML = `Error: ${error}`;
        }

        function tabs(statuses, rootId, rpsTimestampsMap, rpsDatasets, latencyDatasets) {

            /*
                <div id = "{{rootId}}">
                    <div class = "tabs-header">
                        <button id = "button-{{root}}-{{status}}">...</button>
                        ...
                    </div>
                    <div class = "tabs-content">
                        <canvas id = "chart-{{root}}-{{status}}"></canvas>
                        ...
                    </div>
                </div>
            */

            const tabsHeaderDiv = document.createElement("div");
            tabsHeaderDiv.className = "tabs-header";

            const tabsContentDiv = document.createElement("div");
            tabsContentDiv.className = "tabs-content";

            const chartsDiv = document.getElementById(rootId);
            chartsDiv.innerHTML = "";
            chartsDiv.appendChild(tabsHeaderDiv);
            chartsDiv.appendChild(tabsContentDiv);

            for(const status of statuses) {

                const id = `${rootId}-${status}`;

                const tabSelectButton = document.createElement("button");
                tabSelectButton.id = `button-${id}`;
                tabSelectButton.className = "tabs-button";
                tabSelectButton.innerText = `Status: ${status}`;

                tabsHeaderDiv.appendChild(tabSelectButton);

                const chartCanvas = document.createElement("canvas");
                chartCanvas.id = `chart-${id}`;
                chartCanvas.className = "chartjs-canvas"; 
                tabsContentDiv.appendChild(chartCanvas);

                tabSelectButton.onclick = () => {

                    selectTab(rootId, status);
                    renderChart(status, rootId, chartCanvas, rpsTimestampsMap, rpsDatasets, latencyDatasets);
                }
            }
        }

        function selectTab(rootId, status, forceClick) {

            const id = `${rootId}-${status}`;
            const chartsDiv = document.getElementById(rootId);

            for(const button of chartsDiv.getElementsByTagName("button")) {

                if(button.id === `button-${id}`) {

                    button.className = "tabs-button-selected";
                    button.click();
                }

                else {

                    button.className = "tabs-button";
                }
            }

            for(const canvas of chartsDiv.getElementsByTagName("canvas")) {

                if(canvas.id === `chart-${id}`) canvas.className = "chartjs-canvas-selected";
                else canvas.className = "chartjs-canvas";
            }
        }

    </script>

</html>
